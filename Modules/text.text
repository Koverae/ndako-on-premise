PropertyType::create([
    'name' => 'Apartment',
    'description' => 'Multi-unit residential building',
    'slug' => 'apartment',
    'icon' => 'fa-building',
    'attributes' => json_encode([
        'bedrooms' => true,
        'bathrooms' => true,
        'parking_spots' => true,
        'has_elevator' => true,
        'has_pool' => false,
    ]),
    'default_settings' => json_encode([
        'default_bedrooms' => 2,
        'default_parking_spots' => 1,
        'has_elevator' => false,
        'has_pool' => false,
    ]),
]);

$unitTypes = UnitType::with(['unitTypePricings' => function ($query) use ($property) {
    $query->where('property_id', $property->id)
          ->where(function ($query) {
              $query->where('start_date', '<=', now())
                    ->orWhereNull('start_date');
          })
          ->where(function ($query) {
              $query->where('end_date', '>=', now())
                    ->orWhereNull('end_date');
          });
}])->get();




<div class="border rounded booking-form">
    <div id="availabilityResult" style="margin-top: 15px; text-align: center; font-size: 16px;"></div>
    <form id="checkAvailabilityForm">
        <div class="row">
            <div class="col-md-6">
                <div class="form-group">
                    <span class="form-label">Check In</span>
                    <input class="form-control" type="date" id="checkIn" name="check_in" required>
                </div>
                <span class="in-out hidden-xs hidden-sm">&#8652;</span>
            </div>
            <div class="col-md-6">
                <div class="form-group">
                    <span class="form-label">Check out</span>
                    <input class="form-control" type="date" id="checkOut" name="check_out" required>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-md-3">
                <div class="form-group">
                    <span class="form-label">Room Type</span>
                    <select class="form-control" name="room_type" id="roomType">
                        <option value=""></option>
                        @foreach($roomTypes as $type)
                        <option value="{{ $type->id }}">{{ $type->name }}</option>
                        @endforeach
                    </select>
                    {{-- <span class="select-arrow"></span> --}}
                </div>
            </div>
            <div class="col-md-3">
                <div class="form-group">
                    <span class="form-label">Adults</span>
                    <input type="number" id="people" class="form-control" name="people" min="1" required>
                    <span class="select-arrow"></span>
                </div>
            </div>
            <div class="col-md-3">
                <div class="form-group">
                    <span class="form-label">Children</span>
                    <select class="form-control">
                        <option>0</option>
                        <option>1</option>
                        <option>2</option>
                    </select>
                    <span class="select-arrow"></span>
                </div>
            </div>
            <div class="col-md-3">
                <div class="form-btn">
                    <button type="submit" class="submit-btn">Check availability</button>
                </div>
            </div>
        </div>
    </form>
    <div class="container text-center">
        <span class="text-black caveat" style="font-size: 25px;">Powered by <strong><a class="text-black" href="https://ndako.koverae.com">Ndako</a></strong></span>
    </div>
</div>

(function () {
    // Embed script initialization
    window.NdakoEmbed = {
        init: function (formContainerId, apiKey, apiSecret) {
            const container = document.getElementById(formContainerId);

            if (!container) {
                console.error('Form container not found.');
                return;
            }

            // Fetch and load the form
            fetch('http://lantern.koverae.localhost/api/embed/form'
                    , {
                    headers: {
                        'X-API-Key': apiKey,
                        'X-API-Secret': apiSecret,
                    },
                }
            )
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to load form');
                    }
                    return response.text();
                })
                .then(html => {
                    container.innerHTML = html;

                    // Add event listener for form submission
                    document.getElementById('checkAvailabilityForm').addEventListener('submit', async function (e) {
                        e.preventDefault();

                        // Collect form data
                        const checkIn = document.getElementById('checkIn').value;
                        const checkOut = document.getElementById('checkOut').value;
                        const roomType = document.getElementById('roomType').value;
                        const people = document.getElementById('people').value;

                        try {
                            // Send request to the backend
                            const response = await fetch('http://lantern.koverae.localhost/api/check-availability', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-API-Key': apiKey,
                                    'X-API-Secret': apiSecret,
                                },
                                body: JSON.stringify({
                                    check_in: checkIn,
                                    check_out: checkOut,
                                    room_type: roomType,
                                    people: people,
                                }),
                            });

                            if (!response.ok) {
                                if (response.status === 400) {
                                    const errorData = await response.json();
                                    document.getElementById('availabilityResult').textContent = errorData.message;
                                } else {
                                    throw new Error('Something went wrong. Please try again later.');
                                }
                            } else {
                                const result = await response.json();
                                const resultDiv = document.getElementById('availabilityResult');
                                // resultDiv.textContent = result.message;
                                // resultDiv.style.color = result.available ? 'green' : 'red';

                                // Display available rooms if available
                                    fetch('http://lantern.koverae.localhost/api/available-rooms-html', {
                                        headers: {
                                            'X-API-Key': apiKey,
                                            'X-API-Secret': apiSecret,
                                        },
                                    })
                                    .then(response => response.text())
                                    .then(html => {
                                        document.getElementById('availableRooms').innerHTML = html;
                                    })
                                    .catch(error => {
                                        console.error('Error loading available rooms:', error);
                                        document.getElementById('availabilityResult').textContent = 'Failed to load available rooms.';
                                    });
                                if (result.available) {
                                }

                            }
                        } catch (error) {
                            console.error('Error:', error);
                            document.getElementById('availabilityResult').textContent = 'An error occurred. Please try again later.';
                        }
                    });
                })
                .catch(error => console.error('Error loading form:', error));
        },
    };
})();




        // Step 1: Fetch all rooms that fit the number of people
        $rooms = PropertyUnit::where('capacity', '>=', $this->people)
            ->whereDoesntHave('bookings', function ($query) {
                $query->where(function ($query) {
                    $query->where('check_in', '<=', $this->endDate)
                        ->where('check_out', '>=', $this->startDate);
                });
            })
            ->with([
                'unitType',
                'unitType.prices' => fn($query) => $query->where('is_default', true),
                'bookings',
                ])
            ->when($this->filterBy, function ($query) {
                if ($this->filterBy === 'price') {
                    return $query->join('property_types', 'property_units.property_type_id', '=', 'property_types.id')
                                ->join('prices', 'property_types.id', '=', 'prices.property_type_id')
                                ->orderBy('prices.price', $this->sortOrder);
                } elseif($this->filterBy === 'capacity'){
                    return $query->orderBy('capacity', $this->sortOrder);
                } elseif($this->filterBy === 'name'){
                    return $query->orderBy('name', $this->sortOrder);
                }

                return $query->orderBy($this->filterBy, $this->sortOrder);
            }) // Eager load unit type & bookings
            ->get();


            $this->availableRooms = $rooms;

            // $this->availableRooms = $rooms->filter(function ($room) {
            //     $isAvailable = !Booking::where('property_unit_id', $room->id)
            //         ->where(function ($query) {
            //             $query->where(function ($query) {
            //                 $query->where('check_in', '<=', $this->endDate)
            //                       ->where('check_out', '>=', $this->startDate);
            //             });
            //         })
            //         ->exists();

            //     return $isAvailable;
            // })->values();





// CALENDAR

<script>
        document.addEventListener('DOMContentLoaded', function() {
            initializeCalendar();
        });

        // Reinitialize when Livewire updates the component
        document.addEventListener('livewire:load', function () {
            initializeCalendar();
        });
        Livewire.on('calendarUpdated', function() {
            initializeCalendar();
        });

        $wire.on('calendarUpdated', () => {
            initializeCalendar();
        });
        // Livewire.hook('message.processed', (message, component) => {
        //     initializeCalendar();
        // });

        function initializeCalendar() {
            let calendarEl = document.getElementById('calendar');
            if (!calendarEl) return;

            let eventsData = @json($events ?? []);

            let calendar = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                editable: true, // Enable editing
                selectable: true,
                select: function(info) {
                    // Send selected date range to Livewire and open the modal
                    Livewire.dispatch('openModal', {
                        component: 'channelmanager::modal.add-booking-modal',
                        arguments: {
                            startDate: info.startStr,
                            endDate: info.endStr
                        }
                    });
                },
                events: eventsData, // Directly assign JSON data
                timeZone: 'local', // Forces local timezone
                eventDrop: function(info) {
                    let newStart = info.event.start ? new Date(info.event.start) : null;
                    let newEnd = info.event.end.toISOString();

                    if (newStart) {
                        newStart.setDate(newStart.getDate() + 1); // Fix off-by-one issue
                        newStart = newStart.toISOString();
                    }

                    Livewire.dispatch('updateBookingDate', {
                        bookingId: info.event.id,
                        start: newStart,
                        end: newEnd
                    });
                },

                eventResize: function(info) {
                    let newEnd = new Date(info.event.end);
                    let newStart = info.event.start.toISOString();

                    newEnd.setDate(newEnd.getDate() + 1); // Fix off-by-one issue
                    newEnd = newEnd.toISOString();

                    Livewire.dispatch('updateBookingDate', {
                        bookingId: info.event.id,
                        start: newStart,
                        end: newEnd
                    });
                },

                eventMouseEnter: function(info) {
                    let event = info.event;
                    let tooltip = document.createElement('div');
                    tooltip.className = 'calendar-tooltip';
                    tooltip.innerHTML = `
                        <strong>${event.extendedProps.reference}</strong><br>
                        <span>Unit: ${event.title} - ${event.extendedProps.unitType}</span><br>
                        <span>Stay: ${formatDate(event.start)} ~ ${formatDate(event.end)}</span><br />
                        <span>Status: ${event.extendedProps.status}</span>
                    `;
                    document.body.appendChild(tooltip);

                    tooltip.style.left = `${info.jsEvent.pageX + 10}px`;
                    tooltip.style.top = `${info.jsEvent.pageY + 10}px`;

                    info.el.setAttribute('data-tooltip-id', event.id);
                },
                eventMouseLeave: function(info) {
                    let tooltip = document.querySelector(`.calendar-tooltip`);
                    if (tooltip) tooltip.remove();
                },

                eventContent: function(info) {
                    let event = info.event;
                    let statusColor = getStatusColor(event.extendedProps.status);

                    return {
                        html: `<div class="d-flex justify-content-between fc-event-custom" style=" color: white; padding: 5px; border-radius: 5px;">
                                <div class="text-left">
                                    <span class="cursor-pointer" onclick="Livewire.dispatch('openModal', {component: 'channelmanager::modal.booking-modal', arguments: {booking: ${event.id}} })"><strong>${event.title} - ${event.extendedProps.unitType}</strong></span>
                                    <br>
                                    <span style="font-size: 12px;">${event.extendedProps.status ?? ''}</span>
                                </div>

                                <div class="text-right cursor-pointer">
                                    <span class="mb-2" onclick="Livewire.dispatch('openModal', {component: 'channelmanager::modal.guest-booking-modal', arguments: {booking: ${event.id}} })">
                                        <i class="fas fa-user-cog fs-2" style="color: #fff;"></i>
                                    </span>
                                    <br />
                                    <span class="bg-white fs-6 text-primary badge rounded-pill">${event.extendedProps.channel}</span>
                                </div>
                            </div>`
                    };
                },
                // eventClick: function(info) {
                //     Livewire.dispatch('openModal', {
                //         component: 'channelmanager::modal.booking-modal',
                //         arguments: { booking: info.event.id }
                //     });
                //     // alert(`Booking: ${info.event.title}\nStatus: ${info.event.extendedProps?.status ?? 'N/A'}`);
                // },

                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,timeGridWeek,timeGridDay'
                },
                // select: function (info) {
                //     Livewire.emit('bookingSelected', info.startStr, info.endStr);
                // }
            });

            calendar.render();
        }

        // Function to get status color
        function getStatusColor(status) {
            switch (status.toLowerCase()) {
                case 'pending':
                    return '#fbc02d'; // Yellow
                case 'confirmed':
                    return '#017E84'; // Green
                case 'completed':
                    return '#1e88e5'; // Blue
                case 'canceled':
                    return '#e53935'; // Red
                default:
                    return '#757575'; // Gray (Fallback)
            }
        }
</script>










// ADD BOOKING WIZARD
<?php

namespace Modules\ChannelManager\Livewire\Wizard;

use Livewire\Attributes\On;
use Modules\RevenueManager\Services\Pricing\RateService;
use App\Models\User;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Route;
use Modules\App\Livewire\Components\Wizard\SimpleWizard;
use Modules\App\Livewire\Components\Wizard\Step;
use Modules\App\Livewire\Components\Wizard\StepPage;
use Modules\ChannelManager\Models\Booking\Booking;
use Modules\ChannelManager\Models\Booking\BookingInvoice;
use Modules\ChannelManager\Models\Booking\BookingPayment;
use Modules\ChannelManager\Models\Guest\Guest;
use Modules\ChannelManager\Services\Booking\BookingService;
use Modules\Properties\Models\Property\PropertyUnit;
use Modules\RevenueManager\Models\Accounting\Journal;

class AddBookingWizard extends SimpleWizard
{
    public $search = '', $guest, $selectedRoom, $startDate = '', $endDate = '', $guests, $status = 'pending', $paymentStatus = 'unpaid', $invoiceStatus = 'not_invoiced', $paymentMethod = 'cash';
    public $filterBy = 'capacity', $sortOrder = 'asc', $totalAmount = 0, $downPayment = 0, $downPaymentDue = 0, $dueAmount = 0, $nights = 0, $people = 1;
    public $availableRooms = [];
    public array $paymentOptions = [];
    public bool $checkedIn = true;
    protected $rateService, $bookingService;

    // Define validation rules
    protected $rules = [
        // 'guest' => 'nullable|integer|exists:users,id',
        // 'unit' => 'nullable|integer|exists:property_units,id',
        'startDate' => 'required|date|after_or_equal:today',
        'endDate' => 'required|date|after:startDate',
        'people' => 'integer',
        'downPayment' => 'numeric|required',
        'status' => 'nullable|string',
        'checkedIn' => 'nullable|boolean',
    ];

    public function boot(RateService $rateService, BookingService $bookingService){
        $this->rateService = $rateService;
        $this->bookingService = $bookingService;
    }

    public function mount($startDate = null, $endDate = null){

        $this->startDate = $startDate ?? Carbon::now()->format('Y-m-d');
        $this->endDate = $endDate ?? Carbon::now()->addDay()->format('Y-m-d');

        $this->guests = Guest::isCompany(current_company()->id)->get();
        $this->downPaymentDue = $this->totalAmount * 0.3;
        // $this->selectedRoom = PropertyUnit::isCompany(current_company()->id)->first();
        // $this->guest = User::isCompany(current_company()->id)->first();
        $this->availableRooms = PropertyUnit::isCompany(current_company()->id)->get();
        $this->nights = dateDaysDifference($this->startDate, $this->endDate);

        $payments = [
            ['id' => 'cash', 'label' => 'Cash'],
            ['id' => 'bank', 'label' => 'Bank'],
            ['id' => 'm-pesa', 'label' => 'M-Pesa'],
        ];
        $this->paymentOptions = toSelectOptions($payments, 'id', 'label');
    }

    public function steps(){
        return [
            Step::make(0, 'Identity Card', true),
            Step::make(1, 'How Many People', false),
            Step::make(2, 'Pick A Room', false),
            Step::make(3, 'Confirmation', false),
        ];
    }

    public function stepPages(){
        return [
            StepPage::make('identity', 'Identity Card', 0)->component('app::wizard.step-page.special.booking.pick-guest'),
            StepPage::make('people', 'How Many People', 1)->component('app::wizard.step-page.special.booking.view-count'),
            StepPage::make('room', 'Pick A Room', 2)->component('app::wizard.step-page.special.booking.choose-room'),
            StepPage::make('confirmation', 'Confirmation', 3)->component('app::wizard.step-page.special.booking.confirmation'),
        ];
    }
    public function updatedSearch()
    {
        // Update guests based on search term
        $this->guests = Guest::isCompany(current_company()->id)
            ->where('name', 'like', '%' . $this->search . '%')
            ->orWhere('email', 'like', '%' . $this->search . '%')
            ->get();
    }

    public function updated($propertyName)
    {
        // $this->validateOnly($propertyName);

        if ($this->startDate && $this->endDate) {
            $this->validate([
                'startDate' => 'required|date|after_or_equal:today',
                'endDate' => 'required|date|after:startDate',
            ]);

            $this->calculatePrice();
        }

        if ($this->selectedRoom) {
            $this->calculatePrice();
        }

        if ($this->startDate && $this->endDate && $this->guests) {
            $this->filterAvailableRooms();
        }

        // if ($early_check_in && !$this->isRoomAvailableForEarlyCheckIn()) {
        //     $this->addError('early_check_in', 'Early check-in is not available for this room.');
        // }
    }


    public function calculatePrice()
    {
        if($this->selectedRoom){
            $checkIn = Carbon::parse($this->startDate);
            $checkOut = Carbon::parse($this->endDate);
            $nights = $checkIn->diffInDays($checkOut);
            $this->nights = $nights;

            $this->totalAmount = $this->rateService->getOptimalPricing($this->selectedRoom->unitType->id, $nights);

            $this->calculateDownPayment();
        }
    }

    public function calculateDownPayment()
    {
        if(settings()->down_payment){
            $this->downPaymentDue = $this->totalAmount * (settings()->down_payment / 100);
        }else{
            $this->downPaymentDue = 0;
        }
        // $this->downPaymentDue = $this->totalAmount * 0.3;
    }

    #[On('load-guests')]
    public function loadGuests(){
        $this->guests = Guest::isCompany(current_company()->id)->get();
    }

    public function pickGuest($guest){
        $this->guest = Guest::find($guest);
    }

    public function pickRoom($room){
        $this->selectedRoom = PropertyUnit::find($room);
        $this->calculatePrice();

        $this->goToNextStep();
    }

    public function filterAvailableRooms(){
        if (!$this->startDate || !$this->endDate || !$this->people) {
            return;
        }

        $this->availableRooms = PropertyUnit::where('capacity', '>=', $this->people)
            ->where('status', 'vacant') // Step 1: Get rooms that fit the number of people
                ->orWhere('status', 'vacant-clean')
                    ->whereDoesntHave('bookings', function ($query) { // Step 2: Exclude rooms that are already booked in the given date range
                        $query->where('check_in', '<=', $this->endDate)  // Check if check-in date is before or on the selected end date
                                ->where('check_out', '>=', $this->startDate);  // Check if check-out date is after or on the selected start date

                    })
                    ->with([
                        'unitType.prices' => fn($query) => $query->where('is_default', true), // Step 3: Eager load the default pricing for the unit type
                    ])
                    ->get() // Step 4: Fetch all results from the database
                        ->sortBy(fn($room) => match ($this->filterBy) { // Step 5: Sort the results based on user selection
                            'price'    => $room->unitType?->prices->first()?->price ?? 0, // Sort by price if available, otherwise default to 0
                            'capacity' => $room->capacity, // Sort by capacity if selected
                            default    => 0, // Default sorting (if no valid filter is provided)
                        }, SORT_REGULAR, $this->sortOrder === 'desc') // Step 6: Apply sorting order (ascending or descending)
                        ->values(); // Step 7: Reset array keys (in case filtering removed some items)
    }


    public function createBooking(){
        $this->validate();

        // Ensure dueAmount does not exceed totalAmount
        if ($this->downPayment > $this->totalAmount) {
            session()->flash('error', 'The paid amount exceeds the total amount for this booking.');
            return;
        }

        if($this->downPayment >= 1){
            $this->dueAmount = $this->totalAmount - $this->downPayment;
            $this->status = 'confirmed';
            $this->paymentStatus = 'partial';
            $this->invoiceStatus = 'invoiced';
        }

        $booking = Booking::create([
            'company_id' => current_company()->id,
            'property_unit_id' => $this->selectedRoom->id,
            'guest_id' => $this->guest->id,
            'agent_id' => Auth::user()->id,
            'guests' => $this->people,
            'check_in' => $this->startDate,
            'check_out' => $this->endDate,
            'unit_price' => $this->rateService->getDefaultRate($this->selectedRoom->unitType->id)->price,
            'paid_amount' => $this->downPayment,
            'due_amount' => $this->dueAmount,
            'total_amount' => $this->totalAmount,
            'status' => $this->status,
            'payment_status' => $this->paymentStatus,
            'invoice_status' => $this->invoiceStatus,
            // Add the check-in and check-out status fields
            'check_in_status' => 'pending', // Check if check-in is today
            'check_out_status' => 'pending', // Initial status
        ]);
        $booking->save();

        // $this->selectedRoom->update([
        //     'status' => 'occupied'
        // ]);
        if($booking->status == 'confirmed'){
            $this->dispatch('reservation-confirmed', booking: $booking);
        }

        // Check if the booking is for today or a future date
        if ($this->startDate == now()->toDateString()) {
            // If check-in is today, mark the room as occupied immediately
            if($this->checkedIn == true){
                $booking->update([
                    'check_in_status' => 'checked_in'
                ]);
            }
            $this->selectedRoom->update([
                'status' => 'occupied'
            ]);
        } else {
            // If check-in is in the future, mark the room as reserved
            $this->selectedRoom->update([
                'status' => 'expected-arrival'
                // 'status' => 'reserved'
            ]);
        }

        if($booking->paid_amount > 0){
            $this->createInvoice($booking);
        }

        session()->flash('success', __('Booking confirmed! Your reservation has been successfully added.'));

        return $this->redirect(route('bookings.lists'), navigate: true);
        // return $this->redirect(route('bookings.show', ['booking' => $booking->id]), navigate: true);
        // return $this->redirect(route('dashboard', ['dash' => 'home']), navigate: true);

    }

    public function createInvoice($booking){

        $invoice = BookingInvoice::create([
            'company_id' => $booking->company_id,
            'booking_id' => $booking->id,
            'guest_id' => $booking->guest_id,
            'date' => now(),
            'due_date' => $booking->check_out,
            'payment_status' => $booking->payment_status,
            'agent_id' => Auth::user()->id,
            'terms' => $booking->terms,
            'total_amount' => $booking->total_amount,
            'paid_amount' => $booking->paid_amount,
            'due_amount' => $booking->due_amount,
            'status' => 'posted',
            'to_checked' => false,
        ]);
        $invoice->save();

        if($booking->paid_amount >= 0){
            $journal = Journal::isCompany(current_company()->id)->isType($this->paymentMethod)->first();
            $payment = BookingPayment::create([
                'company_id' => $invoice->company_id,
                'booking_invoice_id' => $invoice->id,
                'journal_id' => $journal->id ?? null,
                'amount' => $invoice->paid_amount,
                'due_amount' => $invoice->due_amount,
                'date' => now(),
                'note' => 'Payment Received for Invoice #'. $invoice->reference,
                // 'reference' => $invoice->reference,
                'type' => 'debit',
                'payment_method' => $this->paymentMethod,
            ]);
            $payment->save();
        }

        $booking->update([
            'invoice_status' => 'invoiced'
        ]);
    }

}




                ->where(function ($query) use ($startDate, $endDate) {
                    $query->whereBetween('check_in', [$startDate, $endDate])
                        ->orWhereBetween('check_out', [$startDate, $endDate])
                        ->orWhere(function ($query) use ($startDate, $endDate) {
                            $query->where('check_in', '<', $startDate)
                                    ->where('check_out', '>', $endDate);
                        });
                })


        // {
        //     "regular": ["id_card", "passport", "driving_license"],
        //     "student_housing": ["id_card", "passport", "admission_letter"],
        //     "corporate": ["id_card", "passport", "company_registration"]
        // }
